<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blockchain Explained</title>
    <link rel="icon" href="kaspaimages/FACT0RN_SNOWDRIFT_FRAME_TRANSPARENT.png">
    <link rel="stylesheet" href="crypto.css">
    <link rel="stylesheet" href="fact0rn.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.1/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>

<body>
    <div class="content-wrapper">
        <video src="kaspaimages/10bpsvideoshort.mp4" autoplay loop muted></video>
        <div class="div1">
            <div class="div2">
                <h1 class="header1">Bl0ckcha1n 3xpl@ined</h1>
                
            </div>
        </div>
        <div class="content">
            <nav class="navbar">
                <ul>
                    <li><a href="index.html" class="Dropdownmenu">Home</a></li>
                    <li><a href="bitcoin.html" class="btc">Bitcoin</a></li>
                    <li><a href="kaspa.html" class="kas">Kaspa</a></li>
                    <li><a href="Fact0rn.html" class="fact">Fact0rn</a></li>
                    <li><a href="fact0rn_onchain_data.html" class="Dropdownmenu">Fact0rn On-Chain Data</a></li>
                </ul>
            </nav>

            <h2 class="header2">Fact0rn on chain Data</h2>

            <hr style="height: 1px; background-color: black;">
            <br>
            <br>

            <div id='fact0rn_icon'>
                <a href="https://drive.google.com/file/d/1AJ5_MTIhdI-lz8X35WGi20JNnbN_q2vn/view" target="_blank">
                    <img src="kaspaimages/FACT0RN_SNOWDRIFT_FRAME_TRANSPARENT.png" alt="" width="200" id="fact0rn_icon">
                </a>
            </div>

            <!-- Chart Controls and Container -->
             <!-- Chart Controls and Container -->
             <div class="controls-container" style="margin-bottom: 20px; padding: 15px; background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px;">
                <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 15px;">
                    <div>
                        <label for="blockRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Block Range:</label>
                        <input type="number" id="startBlock" placeholder="Start Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                        <span style="color: #f8f8f8;">to</span>
                        <input type="number" id="endBlock" placeholder="End Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                    </div>
                    
                    <div>
                        <label for="blockDateRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Block Date Range:</label>
                        <input type="date" id="startBlockDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                        <span style="color: #f8f8f8;">to</span>
                        <input type="date" id="endBlockDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                    </div>
                    
                    <div>
                        <label for="limitSelect" style="color: #FF9900; margin-bottom: 5px; display: block;">Number of Blocks:</label>
                        <select id="limitSelect" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px;">
                            <option value="20">Last 20 Blocks</option>
                            <option value="50" selected>Last 50 Blocks</option>
                            <option value="100">Last 100 Blocks</option>
                            <option value="200">Last 200 Blocks</option>
                            <option value="1000">Last 1000 Blocks</option>
                            <option value="max">Max Range</option>
                        </select>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button id="customRangeBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Apply Custom Range</button>
                    <button id="resetZoomBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Reset Zoom</button>
                </div>
            </div>

            <div class="chart-container" style="background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px; padding: 1.5rem; margin: 2rem 0; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); text-align: center;">
                <div id="loading-message">Loading blockchain data...</div>
                <div id="error-details" style="display: none; color: #ff6b6b; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 5px; padding: 1rem; margin: 1rem 0;"></div>
                <button id="retry-button" style="display: none; background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 0.75rem 1.5rem; font-weight: bold; cursor: pointer; margin: 0.5rem;">Retry</button>
                <div style="position: relative; height: 60vh;">
                    <canvas id="blockTimeChart"></canvas>
                </div>
                <!-- Range chart container - pre-created -->
                <div id="rangeChartContainer" style="margin-top: 20px; height: 100px;">
                    <canvas id="rangeChart"></canvas>
                </div>
            </div>

        

            <!-- Emissions Chart Section -->
            <div class="chart-container" style="background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px; padding: 1.5rem; margin: 2rem 0; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); text-align: center;">
                <h3 style="color: #FF9900; font-family: 'Orbitron', sans-serif; margin-bottom: 1rem;">Fact0rn Daily Emissions</h3>
                
                <!-- Emissions Controls -->
                <div class="controls-container" style="margin-bottom: 20px; padding: 15px; background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 15px;">
                        <div>
                            <label for="dateRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Date Range (YYYY-MM-DD):</label>
                            <input type="date" id="startDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                            <span style="color: #f8f8f8;">to</span>
                            <input type="date" id="endDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                        </div>
                        
                        <div>
                            <label for="daysSelect" style="color: #FF9900; margin-bottom: 5px; display: block;">Number of Days:</label>
                            <select id="daysSelect" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px;">
                                <option value="7">Last 7 Days</option>
                                <option value="14">Last 14 Days</option>
                                <option value="30" selected>Last 30 Days</option>
                                <option value="60">Last 60 Days</option>
                                <option value="90">Last 90 Days</option>
                                <option value="max">All Available Data</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                        <button id="emissionsCustomRangeBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Apply Custom Range</button>
                        <button id="emissionsResetZoomBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Reset Zoom</button>
                    </div>
                </div>
                
                <div id="emissions-loading-message">Loading emissions data...</div>
                <div id="emissions-error-details" style="display: none; color: #ff6b6b; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 5px; padding: 1rem; margin: 1rem 0;"></div>
                <button id="emissions-retry-button" style="display: none; background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 0.75rem 1.5rem; font-weight: bold; cursor: pointer; margin: 0.5rem;">Retry</button>
                <div style="position: relative; height: 60vh; margin-top: 1rem;">
                    <canvas id="emissionsChart"></canvas>
                </div>
            </div>

            <!-- Hashrate Chart Section -->
            <div class="chart-container" style="background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px; padding: 1.5rem; margin: 2rem 0; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); text-align: center;">
                <h3 style="color: #FF9900; font-family: 'Orbitron', sans-serif; margin-bottom: 1rem;">Fact0rn Network Hashrate</h3>
                
                <!-- Hashrate Controls -->
                <div class="controls-container" style="margin-bottom: 20px; padding: 15px; background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 15px;">
                        <div>
                            <label for="hashrateBlockRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Block Range:</label>
                            <input type="number" id="hashrateStartBlock" placeholder="Start Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                            <span style="color: #f8f8f8;">to</span>
                            <input type="number" id="hashrateEndBlock" placeholder="End Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                        </div>
                        
                        <div>
                            <label for="hashrateDateRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Date Range:</label>
                            <input type="date" id="hashrateStartDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                            <span style="color: #f8f8f8;">to</span>
                            <input type="date" id="hashrateEndDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                        </div>
                        
                        <div>
                            <label for="hashrateLimit" style="color: #FF9900; margin-bottom: 5px; display: block;">Number of Blocks:</label>
                            <select id="hashrateLimit" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px;">
                                <option value="10">Last 10 Blocks</option>
                                <option value="20">Last 20 Blocks</option>
                                <option value="50" selected>Last 50 Blocks</option>
                                <option value="100">Last 100 Blocks</option>
                                <option value="200">Last 200 Blocks</option>
                                <option value="1000">Last 1000 Blocks</option>
                                <option value="max">All Available Data</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                        <button id="hashrateCustomRangeBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Apply Custom Range</button>
                        <button id="hashrateResetZoomBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Reset Zoom</button>
                    </div>
                </div>
                
                <div id="hashrate-loading-message">Loading hashrate data...</div>
                <div id="hashrate-error-details" style="display: none; color: #ff6b6b; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 5px; padding: 1rem; margin: 1rem 0;"></div>
                <button id="hashrate-retry-button" style="display: none; background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 0.75rem 1.5rem; font-weight: bold; cursor: pointer; margin: 0.5rem;">Retry</button>
                
                <!-- Hashrate Chart -->
                <div style="position: relative; height: 60vh; margin-top: 1rem;">
                    <canvas id="hashrateChart"></canvas>
                </div>
                <!-- Range chart container for hashrate -->
                <div id="hashrateRangeChartContainer" style="margin-top: 20px; height: 100px;">
                    <canvas id="hashrateRangeChart"></canvas>
                </div>
            </div>

            <!-- Block Reward Chart Section -->
            <div class="chart-container" style="background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px; padding: 1.5rem; margin: 2rem 0; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); text-align: center;">
                <h3 style="color: #FF9900; font-family: 'Orbitron', sans-serif; margin-bottom: 1rem;">Fact0rn Block Rewards</h3>
                
                <!-- Block Reward Controls -->
                <div class="controls-container" style="margin-bottom: 20px; padding: 15px; background: rgba(0, 0, 0, 0.6); border: 1px solid #FF9900; border-radius: 10px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 15px;">
                        <div>
                            <label for="rewardBlockRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Block Range:</label>
                            <input type="number" id="rewardStartBlock" placeholder="Start Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                            <span style="color: #f8f8f8;">to</span>
                            <input type="number" id="rewardEndBlock" placeholder="End Block" min="1" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                        </div>
                        
                        <div>
                            <label for="rewardDateRange" style="color: #FF9900; margin-bottom: 5px; display: block;">Date Range:</label>
                            <input type="date" id="rewardStartDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-right: 5px;">
                            <span style="color: #f8f8f8;">to</span>
                            <input type="date" id="rewardEndDate" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px; margin-left: 5px;">
                        </div>
                        
                        <div>
                            <label for="rewardLimit" style="color: #FF9900; margin-bottom: 5px; display: block;">Number of Blocks:</label>
                            <select id="rewardLimit" style="background: #2a2a2a; color: #f8f8f8; border: 1px solid #444; padding: 5px;">
                                <option value="10">Last 10 Blocks</option>
                                <option value="20">Last 20 Blocks</option>
                                <option value="50" selected>Last 50 Blocks</option>
                                <option value="100">Last 100 Blocks</option>
                                <option value="200">Last 200 Blocks</option>
                                <option value="1000">Last 1000 Blocks</option>
                                <option value="max">All Available Data</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                        <button id="rewardCustomRangeBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Apply Custom Range</button>
                        <button id="rewardResetZoomBtn" style="background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer;">Reset Zoom</button>
                    </div>
                </div>
                
                <div id="reward-loading-message">Loading block reward data...</div>
                <div id="reward-error-details" style="display: none; color: #ff6b6b; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 5px; padding: 1rem; margin: 1rem 0;"></div>
                <button id="reward-retry-button" style="display: none; background: #FF9900; color: #000; border: none; border-radius: 5px; padding: 0.75rem 1.5rem; font-weight: bold; cursor: pointer; margin: 0.5rem;">Retry</button>
                
                <!-- Block Reward Chart -->
                <div style="position: relative; height: 60vh; margin-top: 1rem;">
                    <canvas id="rewardChart"></canvas>
                </div>
                <!-- Range chart container for block reward -->
                <div id="rewardRangeChartContainer" style="margin-top: 20px; height: 100px;">
                    <canvas id="rewardRangeChart"></canvas>
                </div>
            </div>

            <script>
                (function() {
                    let chart = null;
                    let rangeChart = null;
                    let allData = []; // Store all data for filtering
                    
                    // Function to show error details
                    function showError(message, details) {
                        const errorElement = document.getElementById('error-details');
                        const loadingElement = document.getElementById('loading-message');
                        const retryButton = document.getElementById('retry-button');
                        
                        loadingElement.textContent = message;
                        
                        if (details) {
                            errorElement.textContent = `Error details: ${details}`;
                            errorElement.style.display = 'block';
                        }
                        
                        retryButton.style.display = 'inline-block';
                    }
                    
                    // Function to clear previous errors and reset UI
                    function resetUI() {
                        const errorElement = document.getElementById('error-details');
                        const loadingElement = document.getElementById('loading-message');
                        const retryButton = document.getElementById('retry-button');
                        
                        loadingElement.textContent = 'Loading blockchain data...';
                        loadingElement.style.display = 'block';
                        errorElement.style.display = 'none';
                        retryButton.style.display = 'none';
                        
                        // Destroy previous charts if they exist
                        if (chart) {
                            chart.destroy();
                            chart = null;
                        }
                        
                        if (rangeChart) {
                            rangeChart.destroy();
                            rangeChart = null;
                        }
                    }
                    
                    // Use a proxy to avoid CORS issues (if needed)
                    function getApiUrl(params = {}) {
                        // Base URL
                        const baseUrl = 'https://fact0rn-data-d59a93edb52f.herokuapp.com/api/blocks';
                        
                        // Build query string from params
                        const queryParams = new URLSearchParams();
                        
                        // Add all params to query string
                        Object.keys(params).forEach(key => {
                            if (params[key] !== null && params[key] !== undefined && params[key] !== 'max') {
                                queryParams.append(key, params[key]);
                            }
                        });
                        
                        // Return full URL with query string
                        return `${baseUrl}?${queryParams.toString()}`;
                    }
                    
                    // Format date for display
                    function formatDate(timestamp) {
                        const date = new Date(timestamp * 1000);
                        return date.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'short', 
                            day: 'numeric' 
                        });
                    }
                    
                    // Function to fetch data from your API
                    async function fetchBlockchainData(params = {}) {
                        resetUI();
                        
                        try {
                            console.log('Fetching data from API with params:', params);
                            
                            // If max range is selected, use a large limit
                            if (params.limit === 'max') {
                                params.limit = 10000; // Very large number to get all blocks
                            }
                            
                            const apiUrl = getApiUrl(params);
                            console.log('API URL:', apiUrl);
                            
                            const response = await fetch(apiUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                },
                                cache: 'no-cache'
                            });
                            
                            console.log('API response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`API responded with status ${response.status}`);
                            }
                            
                            const text = await response.text();
                            console.log('Response text (first 100 chars):', text.substring(0, 100));
                            
                            let data;
                            try {
                                data = JSON.parse(text);
                            } catch (parseError) {
                                console.error('JSON parse error:', parseError);
                                throw new Error(`Failed to parse JSON: ${parseError.message}`);
                            }
                            
                            console.log('Parsed data:', data);
                            
                            // Log a sample data item to check structure
                            if (data && Array.isArray(data) && data.length > 0) {
                                console.log('Sample data item structure:', JSON.stringify(data[0], null, 2));
                            }
                            
                            // Hide loading message
                            document.getElementById('loading-message').style.display = 'none';
                            
                            if (!data || !Array.isArray(data) || data.length === 0) {
                                showError('No data available.', 'API returned empty or invalid data');
                                return;
                            }
                            
                            // Basic validation of data format
                            const firstItem = data[0];
                            if (!firstItem || typeof firstItem !== 'object') {
                                showError('Invalid data format.', 'Data does not contain expected format');
                                console.error('Invalid data format:', firstItem);
                                return;
                            }
                            
                            // Store all data for filtering
                            allData = data;
                            
                            // Apply date filtering if start_date and end_date are provided but no block numbers
                            let filteredData = [...data];
                            if ((params.start_date || params.end_date) && !params.start_block && !params.end_block) {
                                console.log('Filtering data by date:', params.start_date, params.end_date);
                                
                                try {
                                    if (params.start_date) {
                                        const startDate = new Date(params.start_date).getTime() / 1000; // Convert to seconds
                                        if (isNaN(startDate)) {
                                            throw new Error(`Invalid start date format: ${params.start_date}`);
                                        }
                                        filteredData = filteredData.filter(block => block.timestamp >= startDate);
                                        console.log(`Filtered blocks after ${params.start_date}. Remaining blocks: ${filteredData.length}`);
                                    }
                                    
                                    if (params.end_date) {
                                        // Add one day to include the end date
                                        const endDate = new Date(params.end_date);
                                        if (isNaN(endDate.getTime())) {
                                            throw new Error(`Invalid end date format: ${params.end_date}`);
                                        }
                                        endDate.setDate(endDate.getDate() + 1);
                                        const endTimestamp = endDate.getTime() / 1000; // Convert to seconds
                                        
                                        filteredData = filteredData.filter(block => block.timestamp < endTimestamp);
                                        console.log(`Filtered blocks before ${params.end_date}. Remaining blocks: ${filteredData.length}`);
                                    }
                                } catch (dateError) {
                                    console.error('Date filtering error:', dateError);
                                    showError('Date filtering error', dateError.message);
                                    return;
                                }
                                
                                if (filteredData.length === 0) {
                                    showError('No data available for the selected date range.', 'Please try a different range');
                                    return;
                                }
                            }
                            
                            // Check property names consistently
                            const sampleBlock = filteredData[0];
                            console.log('Sample block structure:', JSON.stringify(sampleBlock, null, 2));
                            
                            // Log all available fields to help identify what's available
                            const availableFields = Object.keys(sampleBlock);
                            console.log('All available fields in API response:', availableFields);
                            
                            // Use simple field detection for standard fields
                            const blockNumberField = sampleBlock.hasOwnProperty('height') ? 'height' : 'block_number';
                            const blockTimeField = 'block_time_seconds';
                            const timestampField = 'timestamp';
                            
                            // Explicitly look for moving average fields - check several potential field names
                            let movingAvg100Field = null;
                            let movingAvg672Field = null;
                            
                            // Check possible field names for 100-block MA
                            const possibleMA100Fields = ['moving_avg_100', 'ma_100', 'moving_average_100'];
                            for (const fieldName of possibleMA100Fields) {
                                if (sampleBlock.hasOwnProperty(fieldName)) {
                                    movingAvg100Field = fieldName;
                                    break;
                                }
                            }
                            
                            // If still not found, use a default
                            if (!movingAvg100Field) {
                                movingAvg100Field = 'moving_avg_100';
                            }
                            
                            // Check possible field names for 672-block MA
                            const possibleMA672Fields = ['moving_avg_672', 'ma_672', 'moving_average_672'];
                            for (const fieldName of possibleMA672Fields) {
                                if (sampleBlock.hasOwnProperty(fieldName)) {
                                    movingAvg672Field = fieldName;
                                    break;
                                }
                            }
                            
                            // If still not found, use a default
                            if (!movingAvg672Field) {
                                movingAvg672Field = 'moving_avg_672';
                            }
                            
                            console.log(`Using field names: blockNumber=${blockNumberField}, blockTime=${blockTimeField}, timestamp=${timestampField}`);
                            console.log(`Moving average fields: 100=${movingAvg100Field}, 672=${movingAvg672Field}`);
                            
                            if (!blockNumberField || !blockTimeField || !timestampField) {
                                console.error('Cannot detect one or more required fields in the API response');
                                showError('API Response Structure Error', 'Unable to identify key fields in the data. Check console logs for details.');
                                return;
                            }
                            
                            // Sort by block number ascending
                            const sortedData = filteredData.sort((a, b) => a[blockNumberField] - b[blockNumberField]);
                            
                            const blockNumbers = sortedData.map(block => block[blockNumberField]);
                            const blockTimes = sortedData.map(block => block[blockTimeField]);
                            const blockDates = sortedData.map(block => formatDate(block[timestampField]));
                            
                            // Extract moving average data - check if fields exist before accessing
                            const movingAverages100 = sortedData.map(block => {
                                const value = block[movingAvg100Field];
                                return value !== undefined ? Number(value) : null;
                            });
                            
                            const movingAverages672 = sortedData.map(block => {
                                const value = block[movingAvg672Field];
                                return value !== undefined ? Number(value) : null;
                            });
                            
                            console.log('Moving Average 100 sample:', movingAverages100.slice(0, 5));
                            console.log('Moving Average 672 sample:', movingAverages672.slice(0, 5));
                            
                            // Calculate what percentage of data points are null
                            const nullCount100 = movingAverages100.filter(val => val === null).length;
                            const nullCount672 = movingAverages672.filter(val => val === null).length;
                            
                            console.log(`MA 100 null values: ${nullCount100}/${movingAverages100.length} (${Math.round(nullCount100/movingAverages100.length*100)}%)`);
                            console.log(`MA 672 null values: ${nullCount672}/${movingAverages672.length} (${Math.round(nullCount672/movingAverages672.length*100)}%)`);
                            
                            // If all values are null, log a clear warning
                            if (nullCount672 === movingAverages672.length) {
                                console.warn('All 672 MA values are null - this dataset may be missing in the API response');
                            }
                            
                            // Create main chart
                            const ctx = document.getElementById('blockTimeChart').getContext('2d');
                            chart = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: blockNumbers,
                                    datasets: [
                                        {
                                            label: 'Block Duration',
                                            data: blockTimes,
                                            backgroundColor: 'rgba(0, 0, 0, 0)',
                                            borderColor: 'rgba(0, 0, 255, 1)',
                                            borderWidth: 2,
                                            pointBackgroundColor: 'rgba(0, 0, 255, 1)',
                                            pointRadius: 1,
                                            tension: 0.1,
                                            yAxisID: 'y',
                                            type: 'bar'
                                        },
                                        {
                                            label: '100 Block MA',
                                            data: movingAverages100,
                                            backgroundColor: 'rgba(255, 255, 0, 0.2)',
                                            borderColor: 'rgba(255, 255, 0, 1)',
                                            borderWidth: 2,
                                            pointBackgroundColor: 'rgba(255, 255, 0, 1)',
                                            pointRadius: 0,
                                            tension: 0.1,
                                            yAxisID: 'y',
                                            type: 'line'
                                        },
                                        {
                                            label: '672 Block MA',
                                            data: movingAverages672,
                                            backgroundColor: 'rgba(255, 0, 255, 0.2)',
                                            borderColor: 'rgba(255, 0, 255, 1)',
                                            borderWidth: 2,
                                            pointBackgroundColor: 'rgba(255, 0, 255, 1)',
                                            pointRadius: 0,
                                            tension: 0.1,
                                            yAxisID: 'y',
                                            type: 'line'
                                        }
                                    ]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        title: {
                                            display: true,
                                            text: 'Fact0rn Block Time Analysis',
                                            color: '#f8f8f8',
                                            font: {
                                                family: 'Orbitron',
                                                size: 16
                                            }
                                        },
                                        legend: {
                                            labels: {
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                title: function(tooltipItems) {
                                                    return `Block #${tooltipItems[0].label}`;
                                                },
                                                label: function(context) {
                                                    if (context.dataset.label === 'Block Duration') {
                                                        return `Block Time: ${context.raw} seconds`;
                                                    } else if (context.dataset.label === '100 Block MA') {
                                                        return `100-Block Moving Avg: ${context.raw} seconds`;
                                                    } else if (context.dataset.label === '672 Block MA') {
                                                        return `672-Block Moving Avg: ${context.raw} seconds`;
                                                    }
                                                    return `${context.dataset.label}: ${context.raw}`;
                                                },
                                                afterLabel: function(context) {
                                                    const blockIndex = context.dataIndex;
                                                    const block = sortedData[blockIndex];
                                                    return `Date: ${formatDate(block[timestampField])}`;
                                                }
                                            }
                                        },
                                        zoom: {
                                            pan: {
                                                enabled: true,
                                                mode: 'x'
                                            },
                                            zoom: {
                                                wheel: {
                                                    enabled: true,
                                                },
                                                pinch: {
                                                    enabled: true
                                                },
                                                mode: 'x'
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: {
                                                display: true,
                                                text: 'Block Number',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8',
                                                maxRotation: 45,
                                                minRotation: 45,
                                                callback: function(value, index, values) {
                                                    // Show fewer labels to avoid crowding
                                                    if (index % 5 === 0) {
                                                        const blockIndex = sortedData.findIndex(block => block[blockNumberField] === parseInt(this.getLabelForValue(value)));
                                                        if (blockIndex >= 0) {
                                                            return `${this.getLabelForValue(value)}\n${formatDate(sortedData[blockIndex][timestampField])}`;
                                                        }
                                                        return this.getLabelForValue(value);
                                                    }
                                                    return '';
                                                }
                                            },
                                            
                                        },
                                        y: {
                                            title: {
                                                display: true,
                                                text: 'Block Time (seconds)',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8'
                                            },
                                          
                                        }
                                    }
                                }
                            });
                            
                            // Create range chart
                            const rangeCtx = document.getElementById('rangeChart').getContext('2d');
                            rangeChart = new Chart(rangeCtx, {
                                type: 'line',
                                data: {
                                    labels: blockNumbers,
                                    datasets: [{
                                        label: 'Overview',
                                        data: blockTimes,
                                        backgroundColor: 'rgba(100, 100, 255, 0.2)',
                                        borderColor: 'rgba(100, 100, 255, 0.5)',
                                        borderWidth: 1,
                                        pointRadius: 0
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        legend: {
                                            labels: {
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                title: function(tooltipItems) {
                                                    return `Block #${tooltipItems[0].label}`;
                                                },
                                                label: function(context) {
                                                    if (context.dataset.label === 'Block Duration') {
                                                        return `Block Time: ${context.raw} seconds`;
                                                    } else if (context.dataset.label === '100 Block MA') {
                                                        return `100-Block Moving Avg: ${context.raw} seconds`;
                                                    } else if (context.dataset.label === '672 Block MA') {
                                                        return `672-Block Moving Avg: ${context.raw} seconds`;
                                                    }
                                                    return `${context.dataset.label}: ${context.raw}`;
                                                },
                                                afterLabel: function(context) {
                                                    const blockIndex = context.dataIndex;
                                                    const block = sortedData[blockIndex];
                                                    return `Date: ${formatDate(block[timestampField])}`;
                                                }
                                            }
                                        },
                                        zoom: {
                                            pan: {
                                                enabled: true,
                                                mode: 'x'
                                            },
                                            zoom: {
                                                wheel: {
                                                    enabled: true,
                                                },
                                                pinch: {
                                                    enabled: true
                                                },
                                                mode: 'x'
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: {
                                                display: true,
                                                text: 'Block Number',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8',
                                                maxRotation: 45,
                                                minRotation: 45,
                                                callback: function(value, index, values) {
                                                    // Show fewer labels to avoid crowding
                                                    if (index % 5 === 0) {
                                                        const blockIndex = sortedData.findIndex(block => block[blockNumberField] === parseInt(this.getLabelForValue(value)));
                                                        if (blockIndex >= 0) {
                                                            return `${this.getLabelForValue(value)}\n${formatDate(sortedData[blockIndex][timestampField])}`;
                                                        }
                                                        return this.getLabelForValue(value);
                                                    }
                                                    return '';
                                                }
                                            },
                                            
                                        },
                                        y: {
                                            title: {
                                                display: true,
                                                text: 'Block Time (seconds)',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8'
                                            },
                                          
                                        }
                                    }
                                }
                            });
                            
                        } catch (error) {
                            console.error('Error details:', error);
                            showError('Error loading blockchain data. Please try again later.', error.message);
                        }
                    }
                    
                    // Event listeners for buttons
                    document.addEventListener('DOMContentLoaded', () => {
                        // Event listeners for buttons
                        document.getElementById('retry-button').addEventListener('click', () => {
                            fetchBlockchainData({ limit: document.getElementById('limitSelect').value });
                        });
                        
                        // Custom range button
                        document.getElementById('customRangeBtn').addEventListener('click', () => {
                            const startBlock = document.getElementById('startBlock').value;
                            const endBlock = document.getElementById('endBlock').value;
                            const startBlockDate = document.getElementById('startBlockDate').value;
                            const endBlockDate = document.getElementById('endBlockDate').value;
                            
                            // Validate input
                            if (startBlock && endBlock && parseInt(startBlock) > parseInt(endBlock)) {
                                showError('Invalid block range', 'Start block must be less than or equal to end block');
                                return;
                            }
                            
                            if (startBlockDate && endBlockDate && new Date(startBlockDate) > new Date(endBlockDate)) {
                                showError('Invalid date range', 'Start date must be before end date');
                                return;
                            }
                            
                            // Fetch data with custom range
                            fetchBlockchainData({
                                start_block: startBlock || undefined,
                                end_block: endBlock || undefined,
                                start_date: startBlockDate || undefined,
                                end_date: endBlockDate || undefined,
                                limit: 1000 // Get more blocks to ensure we cover the range
                            });
                        });
                        
                        // Reset zoom button
                        document.getElementById('resetZoomBtn').addEventListener('click', () => {
                            if (chart) {
                                chart.resetZoom();
                            }
                        });
                        
                        // Limit select change
                        document.getElementById('limitSelect').addEventListener('change', () => {
                            // Re-fetch with new limit if last blocks was the most recent selection
                            if (!document.getElementById('startBlock').value && 
                                !document.getElementById('endBlock').value &&
                                !document.getElementById('startBlockDate').value &&
                                !document.getElementById('endBlockDate').value) {
                                fetchBlockchainData({ limit: document.getElementById('limitSelect').value });
                            }
                        });
                        
                        // Initial data load
                        fetchBlockchainData({ limit: document.getElementById('limitSelect').value });
                    });
                })();
            </script>  
            
            <!-- Emissions Data Script -->
            <script>
                (function() {
                    // Private variables for this script
                    let emissionsChart = null;
                    let emissionsData = [];
                    
                    // Show error message
                    function showEmissionsError(message, details) {
                        const errorElement = document.getElementById('emissions-error-details');
                        const loadingElement = document.getElementById('emissions-loading-message');
                        const retryButton = document.getElementById('emissions-retry-button');
                        
                        loadingElement.textContent = message;
                        
                        if (details) {
                            errorElement.textContent = `Error details: ${details}`;
                            errorElement.style.display = 'block';
                        }
                        
                        retryButton.style.display = 'inline-block';
                    }
                    
                    // Reset UI elements
                    function resetEmissionsUI() {
                        const errorElement = document.getElementById('emissions-error-details');
                        const loadingElement = document.getElementById('emissions-loading-message');
                        const retryButton = document.getElementById('emissions-retry-button');
                        
                        loadingElement.textContent = 'Loading emissions data...';
                        loadingElement.style.display = 'block';
                        errorElement.style.display = 'none';
                        retryButton.style.display = 'none';
                        
                        // Destroy previous chart if it exists
                        if (emissionsChart) {
                            emissionsChart.destroy();
                            emissionsChart = null;
                        }
                    }
                    
                    // Format date for display
                    function formatEmissionsDate(dateStr) {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'short', 
                            day: 'numeric' 
                        });
                    }
                    
                    // Function to fetch emissions data
                    async function fetchEmissionsData(options = {}) {
                        resetEmissionsUI();
                        
                        try {
                            console.log('Fetching emissions data from API');
                            
                            const apiUrl = 'https://fact0rn-data-d59a93edb52f.herokuapp.com/api/emissions/daily';
                            
                            const response = await fetch(apiUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                },
                                cache: 'no-cache'
                            });
                            
                            console.log('Emissions API response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`Emissions API responded with status ${response.status}`);
                            }
                            
                            const text = await response.text();
                            console.log('Emissions response text (first 100 chars):', text.substring(0, 100));
                            
                            let data;
                            try {
                                data = JSON.parse(text);
                            } catch (parseError) {
                                console.error('JSON parse error:', parseError);
                                throw new Error(`Failed to parse emissions JSON: ${parseError.message}`);
                            }
                            
                            console.log('Parsed emissions data:', data);
                            
                            // Hide loading message
                            document.getElementById('emissions-loading-message').style.display = 'none';
                            
                            if (!data || !Array.isArray(data) || data.length === 0) {
                                showEmissionsError('No emissions data available.', 'API returned empty or invalid data');
                                return;
                            }
                            
                            // Basic validation of data format
                            const firstItem = data[0];
                            if (!firstItem || typeof firstItem !== 'object') {
                                showEmissionsError('Invalid data format.', 'Data does not contain expected format');
                                console.error('Invalid data format:', firstItem);
                                return;
                            }
                            
                            // Store full data set
                            emissionsData = data;
                            
                            // Sort data by date ascending
                            let sortedData = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));

                            // Apply date filtering if options are provided
                            if (options.start_date || options.end_date || options.days) {
                                console.log('Applying date filters:', options);
                                
                                try {
                                    // Filter by specific date range if both start and end dates are provided
                                    if (options.start_date && options.end_date) {
                                        const startDate = new Date(options.start_date);
                                        const endDate = new Date(options.end_date);
                                        
                                        if (isNaN(startDate.getTime())) {
                                            throw new Error(`Invalid start date format: ${options.start_date}`);
                                        }
                                        
                                        if (isNaN(endDate.getTime())) {
                                            throw new Error(`Invalid end date format: ${options.end_date}`);
                                        }
                                        
                                        // Add one day to end date to include the end date in the range
                                        endDate.setDate(endDate.getDate() + 1);
                                        
                                        sortedData = sortedData.filter(item => {
                                            const itemDate = new Date(item.date);
                                            return itemDate >= startDate && itemDate < endDate;
                                        });
                                        
                                        console.log(`Filtered data by date range: ${options.start_date} to ${options.end_date}. Remaining data points: ${sortedData.length}`);
                                    } 
                                    // Filter by last N days if days option is provided
                                    else if (options.days && options.days !== 'max') {
                                        const days = parseInt(options.days);
                                        if (isNaN(days)) {
                                            throw new Error(`Invalid days value: ${options.days}`);
                                        }
                                        
                                        const cutoffDate = new Date();
                                        cutoffDate.setDate(cutoffDate.getDate() - days);
                                        
                                        sortedData = sortedData.filter(item => {
                                            return new Date(item.date) >= cutoffDate;
                                        });
                                        
                                        console.log(`Filtered data to last ${days} days. Remaining data points: ${sortedData.length}`);
                                    }
                                } catch (dateError) {
                                    console.error('Emissions date filtering error:', dateError);
                                    showEmissionsError('Date filtering error', dateError.message);
                                    return;
                                }
                            }
                            
                            if (sortedData.length === 0) {
                                showEmissionsError('No data available for the selected date range.', 'Please try a different range');
                                return;
                            }
                            
                            const dates = sortedData.map(item => formatEmissionsDate(item.date));
                            const emissions = sortedData.map(item => parseFloat(item.daily_emission));
                            const blockCounts = sortedData.map(item => item.block_count);
                            
                            // Create emissions chart
                            const ctx = document.getElementById('emissionsChart').getContext('2d');
                            emissionsChart = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: dates,
                                    datasets: [
                                        {
                                            label: 'Daily Emissions (FACT)',
                                            data: emissions,
                                            backgroundColor: 'rgba(255, 153, 0, 0.2)',
                                            borderColor: 'rgba(255, 153, 0, 1)',
                                            borderWidth: 3,
                                            pointBackgroundColor: 'rgba(255, 153, 0, 1)',
                                            pointRadius: 4,
                                            tension: 0.1
                                        }
                                    ]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        title: {
                                            display: true,
                                            text: 'Fact0rn Daily Emissions',
                                            color: '#f8f8f8',
                                            font: {
                                                family: 'Orbitron',
                                                size: 16
                                            }
                                        },
                                        legend: {
                                            labels: {
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                title: function(tooltipItems) {
                                                    return tooltipItems[0].label;
                                                },
                                                label: function(context) {
                                                    const dataIndex = context.dataIndex;
                                                    const block = sortedData[dataIndex];
                                                    // Each block emits 16.65 tokens
                                                    const blockReward = 16.65;
                                                    // Calculate total emission based on block count
                                                    const calculatedEmission = block.block_count * blockReward;
                                                    
                                                    // Check if there's a discrepancy between API and calculated values
                                                    if (Math.abs(calculatedEmission - context.raw) > 1) {
                                                        console.warn(`Emissions discrepancy detected: API reports ${context.raw} FACT but calculation (${block.block_count} blocks * ${blockReward}) = ${calculatedEmission} FACT`);
                                                        // Return both values for transparency
                                                        return `Daily Emission: ${calculatedEmission.toFixed(2)} FACT (Calculated)`;
                                                    }
                                                    
                                                    return `Daily Emission: ${calculatedEmission.toFixed(2)} FACT`;
                                                },
                                                afterLabel: function(context) {
                                                    const dataIndex = context.dataIndex;
                                                    const block = sortedData[dataIndex];
                                                    return `Blocks Mined: ${block.block_count}`;
                                                }
                                            }
                                        },
                                        zoom: {
                                            pan: {
                                                enabled: true,
                                                mode: 'x'
                                            },
                                            zoom: {
                                                wheel: {
                                                    enabled: true,
                                                },
                                                pinch: {
                                                    enabled: true
                                                },
                                                mode: 'x'
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: {
                                                display: true,
                                                text: 'Date',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8',
                                                maxRotation: 45,
                                                minRotation: 45
                                            }
                                        },
                                        y: {
                                            title: {
                                                display: true,
                                                text: 'Daily Emission (FACT)',
                                                color: '#f8f8f8',
                                                font: {
                                                    family: 'Orbitron'
                                                }
                                            },
                                            ticks: {
                                                color: '#f8f8f8'
                                            }
                                        }
                                    }
                                }
                            });
                            
                        } catch (error) {
                            console.error('Emissions error details:', error);
                            showEmissionsError('Error loading emissions data. Please try again later.', error.message);
                        }
                    }
                    
                    // Event listeners
                    document.addEventListener('DOMContentLoaded', function() {
                        // Retry button listener
                        document.getElementById('emissions-retry-button').addEventListener('click', fetchEmissionsData);
                        
                        // Custom range button
                        document.getElementById('emissionsCustomRangeBtn').addEventListener('click', () => {
                            const startDate = document.getElementById('startDate').value;
                            const endDate = document.getElementById('endDate').value;
                            const days = document.getElementById('daysSelect').value;
                            
                            // Validate input
                            if (startDate && endDate && new Date(startDate) > new Date(endDate)) {
                                showEmissionsError('Invalid date range', 'Start date must be before end date');
                                return;
                            }
                            
                            // Fetch data with custom range
                            fetchEmissionsData({
                                start_date: startDate || undefined,
                                end_date: endDate || undefined,
                                days: days || undefined
                            });
                        });
                        
                        // Reset zoom button
                        document.getElementById('emissionsResetZoomBtn').addEventListener('click', () => {
                            if (emissionsChart) {
                                emissionsChart.resetZoom();
                            }
                        });
                        
                        // Initial data load
                        fetchEmissionsData();
                    });
                })();
            
            </script>

            <script>
                // Hashrate Chart Functions
                function formatHashRate(hashrateValue) {
                    // Convert to more readable format (H/s, KH/s, MH/s, GH/s, TH/s, PH/s, EH/s)
                    const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
                    let unitIndex = 0;
                    let formattedValue = hashrateValue;
                    
                    while (formattedValue >= 1000 && unitIndex < units.length - 1) {
                        formattedValue /= 1000;
                        unitIndex++;
                    }
                    
                    return formattedValue.toFixed(2) + ' ' + units[unitIndex];
                }
                
                function formatHashRateRaw(hashrateValue) {
                    // Convert to more readable format without units for chart
                    let unitIndex = 0;
                    let formattedValue = hashrateValue;
                    
                    while (formattedValue >= 1000 && unitIndex < 6) { // 6 is the max index (EH/s)
                        formattedValue /= 1000;
                        unitIndex++;
                    }
                    
                    return {
                        value: formattedValue.toFixed(2),
                        unit: ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'][unitIndex]
                    };
                }
                
                function showHashrateError(message, details) {
                    const errorElement = document.getElementById('hashrate-error-details');
                    const loadingElement = document.getElementById('hashrate-loading-message');
                    const retryButton = document.getElementById('hashrate-retry-button');
                    const chartCanvas = document.getElementById('hashrateChart').parentElement;
                    const rangeChartCanvas = document.getElementById('hashrateRangeChartContainer');
                    
                    loadingElement.style.display = 'none';
                    errorElement.style.display = 'block';
                    retryButton.style.display = 'inline-block';
                    chartCanvas.style.display = 'none';
                    rangeChartCanvas.style.display = 'none';
                    
                    errorElement.innerHTML = `<strong>Error:</strong> ${message}`;
                    if (details) {
                        errorElement.innerHTML += `<br><pre>${details}</pre>`;
                    }
                }
                
                function resetHashrateUI() {
                    const errorElement = document.getElementById('hashrate-error-details');
                    const loadingElement = document.getElementById('hashrate-loading-message');
                    const retryButton = document.getElementById('hashrate-retry-button');
                    const chartCanvas = document.getElementById('hashrateChart').parentElement;
                    const rangeChartCanvas = document.getElementById('hashrateRangeChartContainer');
                    
                    errorElement.style.display = 'none';
                    loadingElement.style.display = 'block';
                    retryButton.style.display = 'none';
                    chartCanvas.style.display = 'none';
                    rangeChartCanvas.style.display = 'none';
                }
                
                let hashrateChart = null;
                let hashrateRangeChart = null;
                let hashrateAllData = []; // Store all data for filtering
                
                function fetchHashrateData(options = {}) {
                    resetHashrateUI();
                    
                    // Set default options
                    const defaultOptions = {
                        limit: 50,
                        startBlock: null,
                        endBlock: null,
                        startDate: null,
                        endDate: null
                    };
                    
                    // Merge options with defaults
                    const finalOptions = { ...defaultOptions, ...options };
                    
                    // API URL
                    const apiUrl = 'https://fact0rn-data-d59a93edb52f.herokuapp.com/api/all-data';
                    
                    fetch(apiUrl)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! Status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Store all data for future filtering
                            hashrateAllData = [...data];
                            
                            // Filter data based on options
                            let filteredData = [...data];
                            
                            // Filter by block range if specified
                            if (finalOptions.startBlock && finalOptions.endBlock) {
                                filteredData = filteredData.filter(item => 
                                    item.block_number >= finalOptions.startBlock && 
                                    item.block_number <= finalOptions.endBlock
                                );
                            }
                            
                            // Filter by date range if specified
                            if (finalOptions.startDate && finalOptions.endDate) {
                                const startTimestamp = new Date(finalOptions.startDate).getTime() / 1000;
                                const endTimestamp = new Date(finalOptions.endDate).getTime() / 1000 + 86400; // Add 1 day to include the end date
                                
                                filteredData = filteredData.filter(item => 
                                    item.timestamp >= startTimestamp && 
                                    item.timestamp <= endTimestamp
                                );
                            }
                            
                            // Sort by timestamp in ascending order for the chart
                            filteredData.sort((a, b) => a.timestamp - b.timestamp);
                            
                            // Limit the number of items if specified
                            if (finalOptions.limit !== 'max') {
                                filteredData = filteredData.slice(-parseInt(finalOptions.limit));
                            }
                            
                            // Create the chart
                            createHashrateChart(filteredData);
                        })
                        .catch(error => {
                            console.error('Error fetching hashrate data:', error);
                            showHashrateError('Failed to fetch hashrate data', error.message);
                        });
                }
                
                function createHashrateChart(data) {
                    const loadingElement = document.getElementById('hashrate-loading-message');
                    const chartCanvas = document.getElementById('hashrateChart').parentElement;
                    const rangeChartCanvas = document.getElementById('hashrateRangeChartContainer');
                    
                    if (data.length === 0) {
                        loadingElement.textContent = 'No data available for the selected range.';
                        return;
                    }
                    
                    // Hide loading message and show chart
                    loadingElement.style.display = 'none';
                    chartCanvas.style.display = 'block';
                    rangeChartCanvas.style.display = 'block';
                    
                    // Format the data for the chart
                    const labels = data.map(item => new Date(item.timestamp * 1000));
                    const blockNumbers = data.map(item => item.block_number);
                    
                    // Process hashrate values to use consistent units
                    const processedHashrates = data.map(item => formatHashRateRaw(item.network_hashrate));
                    const commonUnit = findMostCommonUnit(processedHashrates);
                    const hashrateValues = processedHashrates.map(item => {
                        // Convert all values to the same unit
                        const unitDiff = getUnitIndex(item.unit) - getUnitIndex(commonUnit);
                        return parseFloat(item.value) * Math.pow(1000, unitDiff);
                    });
                    
                    // Destroy existing chart if it exists
                    if (hashrateChart) {
                        hashrateChart.destroy();
                    }
                    if (hashrateRangeChart) {
                        hashrateRangeChart.destroy();
                    }
                    
                    // Create main chart
                    const ctx = document.getElementById('hashrateChart').getContext('2d');
                    hashrateChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Network Hashrate (${commonUnit})`,
                                data: hashrateValues,
                                borderColor: '#FF9900',
                                backgroundColor: 'rgba(255, 153, 0, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.2,
                                pointRadius: 3,
                                pointHoverRadius: 6,
                                pointBackgroundColor: '#FF9900'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: {
                                            enabled: true,
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        mode: 'x'
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(tooltipItems) {
                                            const date = new Date(tooltipItems[0].parsed.x);
                                            return date.toLocaleString();
                                        },
                                        afterTitle: function(tooltipItems) {
                                            const index = tooltipItems[0].dataIndex;
                                            return `Block: ${blockNumbers[index]}`;
                                        }
                                    }
                                },
                                legend: {
                                    labels: {
                                        color: '#f8f8f8',
                                        font: {
                                            family: "'Orbitron', sans-serif",
                                            size: 12
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        displayFormats: {
                                            day: 'MMM d, yyyy'
                                        }
                                    },
                                    ticks: {
                                        color: '#f8f8f8'
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    }
                                },
                                y: {
                                    beginAtZero: false,
                                    ticks: {
                                        color: '#f8f8f8'
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                    
                    // Create range chart
                    const rangeCtx = document.getElementById('hashrateRangeChart').getContext('2d');
                    hashrateRangeChart = new Chart(rangeCtx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Network Hashrate Overview`,
                                data: hashrateValues,
                                borderColor: '#FF9900',
                                backgroundColor: 'rgba(255, 153, 0, 0.3)',
                                borderWidth: 1,
                                fill: true,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    enabled: false
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    display: false
                                },
                                y: {
                                    display: false
                                }
                            },
                            interaction: {
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });
                }
                
                function findMostCommonUnit(processedHashrates) {
                    // Count occurrences of each unit
                    const unitCounts = {};
                    processedHashrates.forEach(item => {
                        unitCounts[item.unit] = (unitCounts[item.unit] || 0) + 1;
                    });
                    
                    // Find the most common unit
                    let mostCommonUnit = 'H/s';
                    let maxCount = 0;
                    
                    for (const [unit, count] of Object.entries(unitCounts)) {
                        if (count > maxCount) {
                            mostCommonUnit = unit;
                            maxCount = count;
                        }
                    }
                    
                    return mostCommonUnit;
                }
                
                function getUnitIndex(unit) {
                    const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
                    return units.indexOf(unit);
                }
                
                function initHashrateChart() {
                    // Add event listeners for hashrate chart controls
                    document.getElementById('hashrateCustomRangeBtn').addEventListener('click', function() {
                        const startBlock = document.getElementById('hashrateStartBlock').value;
                        const endBlock = document.getElementById('hashrateEndBlock').value;
                        const startDate = document.getElementById('hashrateStartDate').value;
                        const endDate = document.getElementById('hashrateEndDate').value;
                        
                        const options = {
                            limit: 'max' // Use max when custom range is applied
                        };
                        
                        if (startBlock && endBlock) {
                            options.startBlock = parseInt(startBlock);
                            options.endBlock = parseInt(endBlock);
                        }
                        
                        if (startDate && endDate) {
                            options.startDate = startDate;
                            options.endDate = endDate;
                        }
                        
                        fetchHashrateData(options);
                    });
                    
                    document.getElementById('hashrateResetZoomBtn').addEventListener('click', function() {
                        if (hashrateChart) {
                            hashrateChart.resetZoom();
                        }
                    });
                    
                    document.getElementById('hashrateLimit').addEventListener('change', function() {
                        const limit = this.value;
                        fetchHashrateData({ limit });
                    });
                    
                    document.getElementById('hashrate-retry-button').addEventListener('click', function() {
                        fetchHashrateData();
                    });
                    
                    // Initial data fetch
                    fetchHashrateData();
                }
                
                document.addEventListener('DOMContentLoaded', function() {
                    initHashrateChart();
                });
            </script>

            <script>
                // Block Reward Chart Functions
                function showRewardError(message, details) {
                    const errorElement = document.getElementById('reward-error-details');
                    const loadingElement = document.getElementById('reward-loading-message');
                    const retryButton = document.getElementById('reward-retry-button');
                    const chartCanvas = document.getElementById('rewardChart').parentElement;
                    const rangeChartCanvas = document.getElementById('rewardRangeChartContainer');
                    
                    loadingElement.style.display = 'none';
                    errorElement.style.display = 'block';
                    retryButton.style.display = 'inline-block';
                    chartCanvas.style.display = 'none';
                    rangeChartCanvas.style.display = 'none';
                    
                    errorElement.innerHTML = `<strong>Error:</strong> ${message}`;
                    if (details) {
                        errorElement.innerHTML += `<br><pre>${details}</pre>`;
                    }
                }
                
                function resetRewardUI() {
                    const errorElement = document.getElementById('reward-error-details');
                    const loadingElement = document.getElementById('reward-loading-message');
                    const retryButton = document.getElementById('reward-retry-button');
                    const chartCanvas = document.getElementById('rewardChart').parentElement;
                    const rangeChartCanvas = document.getElementById('rewardRangeChartContainer');
                    
                    errorElement.style.display = 'none';
                    loadingElement.style.display = 'block';
                    retryButton.style.display = 'none';
                    chartCanvas.style.display = 'none';
                    rangeChartCanvas.style.display = 'none';
                }
                
                let rewardChart = null;
                let rewardRangeChart = null;
                let rewardAllData = []; // Store all data for filtering
                
                function fetchRewardData(options = {}) {
                    resetRewardUI();
                    
                    // Set default options
                    const defaultOptions = {
                        limit: 50,
                        startBlock: null,
                        endBlock: null,
                        startDate: null,
                        endDate: null
                    };
                    
                    // Merge options with defaults
                    const finalOptions = { ...defaultOptions, ...options };
                    
                    // API URL
                    const apiUrl = 'https://fact0rn-data-d59a93edb52f.herokuapp.com/api/all-data';
                    
                    fetch(apiUrl)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! Status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Store all data for future filtering
                            rewardAllData = [...data];
                            
                            // Filter data based on options
                            let filteredData = [...data];
                            
                            // Filter by block range if specified
                            if (finalOptions.startBlock && finalOptions.endBlock) {
                                filteredData = filteredData.filter(item => 
                                    item.block_number >= finalOptions.startBlock && 
                                    item.block_number <= finalOptions.endBlock
                                );
                            }
                            
                            // Filter by date range if specified
                            if (finalOptions.startDate && finalOptions.endDate) {
                                const startTimestamp = new Date(finalOptions.startDate).getTime() / 1000;
                                const endTimestamp = new Date(finalOptions.endDate).getTime() / 1000 + 86400; // Add 1 day to include the end date
                                
                                filteredData = filteredData.filter(item => 
                                    item.timestamp >= startTimestamp && 
                                    item.timestamp <= endTimestamp
                                );
                            }
                            
                            // Sort by timestamp in ascending order for the chart
                            filteredData.sort((a, b) => a.timestamp - b.timestamp);
                            
                            // Limit the number of items if specified
                            if (finalOptions.limit !== 'max') {
                                filteredData = filteredData.slice(-parseInt(finalOptions.limit));
                            }
                            
                            // Create the chart
                            createRewardChart(filteredData);
                        })
                        .catch(error => {
                            console.error('Error fetching block reward data:', error);
                            showRewardError('Failed to fetch block reward data', error.message);
                        });
                }
                
                function createRewardChart(data) {
                    const loadingElement = document.getElementById('reward-loading-message');
                    const chartCanvas = document.getElementById('rewardChart').parentElement;
                    const rangeChartCanvas = document.getElementById('rewardRangeChartContainer');
                    
                    if (data.length === 0) {
                        loadingElement.textContent = 'No data available for the selected range.';
                        return;
                    }
                    
                    // Hide loading message and show chart
                    loadingElement.style.display = 'none';
                    chartCanvas.style.display = 'block';
                    rangeChartCanvas.style.display = 'block';
                    
                    // Format the data for the chart
                    const labels = data.map(item => new Date(item.timestamp * 1000));
                    const blockNumbers = data.map(item => item.block_number);
                    const rewardValues = data.map(item => item.block_reward);
                    
                    // Destroy existing chart if it exists
                    if (rewardChart) {
                        rewardChart.destroy();
                    }
                    if (rewardRangeChart) {
                        rewardRangeChart.destroy();
                    }
                    
                    // Create main chart
                    const ctx = document.getElementById('rewardChart').getContext('2d');
                    rewardChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Block Reward (FACT)',
                                data: rewardValues,
                                borderColor: '#FF9900',
                                backgroundColor: 'rgba(255, 153, 0, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.2,
                                pointRadius: 3,
                                pointHoverRadius: 6,
                                pointBackgroundColor: '#FF9900'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: {
                                            enabled: true,
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        mode: 'x'
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(tooltipItems) {
                                            const date = new Date(tooltipItems[0].parsed.x);
                                            return date.toLocaleString();
                                        },
                                        afterTitle: function(tooltipItems) {
                                            const index = tooltipItems[0].dataIndex;
                                            return `Block: ${blockNumbers[index]}`;
                                        },
                                        label: function(context) {
                                            return `Reward: ${context.raw.toFixed(8)} FACT`;
                                        }
                                    }
                                },
                                legend: {
                                    labels: {
                                        color: '#f8f8f8',
                                        font: {
                                            family: "'Orbitron', sans-serif",
                                            size: 12
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        displayFormats: {
                                            day: 'MMM d, yyyy'
                                        }
                                    },
                                    ticks: {
                                        color: '#f8f8f8'
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    }
                                },
                                y: {
                                    beginAtZero: false,
                                    ticks: {
                                        color: '#f8f8f8',
                                        callback: function(value) {
                                            return value.toFixed(2) + ' FACT';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                    
                    // Create range chart
                    const rangeCtx = document.getElementById('rewardRangeChart').getContext('2d');
                    rewardRangeChart = new Chart(rangeCtx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Block Reward Overview',
                                data: rewardValues,
                                borderColor: '#FF9900',
                                backgroundColor: 'rgba(255, 153, 0, 0.3)',
                                borderWidth: 1,
                                fill: true,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    enabled: false
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    display: false
                                },
                                y: {
                                    display: false
                                }
                            },
                            interaction: {
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });
                }
                
                function initBlockRewardChart() {
                    // Add event listeners for block reward chart controls
                    document.getElementById('rewardCustomRangeBtn').addEventListener('click', function() {
                        const startBlock = document.getElementById('rewardStartBlock').value;
                        const endBlock = document.getElementById('rewardEndBlock').value;
                        const startDate = document.getElementById('rewardStartDate').value;
                        const endDate = document.getElementById('rewardEndDate').value;
                        
                        const options = {
                            limit: 'max' // Use max when custom range is applied
                        };
                        
                        if (startBlock && endBlock) {
                            options.startBlock = parseInt(startBlock);
                            options.endBlock = parseInt(endBlock);
                        }
                        
                        if (startDate && endDate) {
                            options.startDate = startDate;
                            options.endDate = endDate;
                        }
                        
                        fetchRewardData(options);
                    });
                    
                    document.getElementById('rewardResetZoomBtn').addEventListener('click', function() {
                        if (rewardChart) {
                            rewardChart.resetZoom();
                        }
                    });
                    
                    document.getElementById('rewardLimit').addEventListener('change', function() {
                        const limit = this.value;
                        fetchRewardData({ limit });
                    });
                    
                    document.getElementById('reward-retry-button').addEventListener('click', function() {
                        fetchRewardData();
                    });
                    
                    // Initial data fetch
                    fetchRewardData();
                }
            </script>

            <script>
                document.addEventListener('DOMContentLoaded', function() {
                    initHashrateChart();
                    initBlockRewardChart();
                });
            </script>

            <script>
                function copyAddress(element) {
                    const text = element.querySelector('.address').innerText;
                    navigator.clipboard.writeText(text);
                    
                    const feedback = document.querySelector('.copy-feedback');
                    feedback.style.display = 'block';
                    feedback.style.animation = 'none';
                    void feedback.offsetHeight; // Trigger reflow
                    feedback.style.animation = 'fadeOut 1.5s ease 1s forwards';
                }
            </script>

            <script>
                function copyAddress(element) {
                    const text = element.querySelector('.address').innerText;
                    navigator.clipboard.writeText(text);
                    
                    const feedback = document.querySelector('.copy-feedback');
                    feedback.style.display = 'block';
                    feedback.style.animation = 'none';
                    void feedback.offsetHeight; // Trigger reflow
                    feedback.style.animation = 'fadeOut 1.5s ease 1s forwards';
                }
            </script>
        </div>
    </div>
    <div class="donation-floater">
        <button class="donate-btn">Support</button>
        <div class="address-card">
          <div class="copy-feedback">Address copied!</div>
          <div class="address-group" onclick="copyAddress(this)">
            <span class="coin-label">FACT0RN</span>
            <code class="address">fact1qcnuygmqfupp4kvu374tgwlt888j2pwzftaxp6l</code>
          </div>
          <div class="address-group" onclick="copyAddress(this)">
            <span class="coin-label">KASPA</span>
            <code class="address">kaspa:qq9ndkzctcgwxwqrk2sc8n78ugh3etpaggdhjenz8vzkvxqp8v3musgahwrvz</code>
          </div>
          <div class="address-group" onclick="copyAddress(this)">
            <span class="coin-label">BITCOIN</span>
            <code class="address">3JA6trsjNfTUxo273DdDL3iZZt5PEPZ6jV</code>
          </div>
          <div class="address-group" onclick="copyAddress(this)">
            <span class="coin-label">MONERO</span>
            <code class="address">84Wio7KcAvtFgjH5fUpGRghQwRuqcRyseNaCH1Hvpcx2igMXWzTAPL8Dv4SKTCo5obKFmFkuhyb1tWuuRen4VvNg2njR84g</code>
          </div>
        </div>
      </div>
</body>
</html>